# llm_client.py
from __future__ import annotations

import os
import logging
from typing import Dict, List

try:
    # –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –∫–ª–∏–µ–Ω—Ç SDK v1.x
    from openai import AsyncOpenAI
except Exception:  # pragma: no cover
    AsyncOpenAI = None  # type: ignore

log = logging.getLogger("llm_client")


class LLMError(RuntimeError):
    pass


class LLMClient:
    def __init__(
        self,
        api_key: str,
        model_nano: str = "gpt-5-nano",
        model_mini: str = "gpt-5-mini",
        model_major: str = "gpt-5",
        daily_token_budget: int = 30000,
    ):
        self.api_key = api_key or os.getenv("OPENAI_API_KEY") or ""
        self.model_nano = model_nano
        self.model_mini = model_mini
        self.model_major = model_major
        self.daily_budget = daily_token_budget
        self._client = None
        if AsyncOpenAI and self.api_key:
            try:
                self._client = AsyncOpenAI(api_key=self.api_key)
            except Exception as e:
                log.warning(f"OpenAI client init failed: {e}")

    def _require_client(self):
        if not self._client:
            raise LLMError("OpenAI client –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω (–ø—Ä–æ–≤–µ—Ä—å—Ç–µ OPENAI_API_KEY).")

    async def _call_mini(self, system: str, user: str, max_tokens: int = 600) -> str:
        """
        –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –≤—ã–∑–æ–≤: —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º Responses API (max_output_tokens),
        –µ—Å–ª–∏ –ø—Ä–æ–≤–∞–ª ‚Äî Chat Completions (max_tokens).
        """
        self._require_client()
        # 1) Responses API
        try:
            resp = await self._client.responses.create(  # type: ignore[union-attr]
                model=self.model_mini,
                input=[
                    {"role": "system", "content": system},
                    {"role": "user", "content": user},
                ],
                max_output_tokens=max_tokens,
                temperature=0.3,
            )
            # —É Responses —É–¥–æ–±–Ω–æ –≤—ã—Ç–∞—Å–∫–∏–≤–∞—Ç—å —Å—Ä–∞–∑—É —Ç–µ–∫—Å—Ç:
            out = getattr(resp, "output_text", None)
            if out:
                return out.strip()
            # fallback: —Å–æ–±—Ä–∞—Ç—å —Ç–µ–∫—Å—Ç –≤—Ä—É—á–Ω—É—é
            try:
                chunks = []
                for item in resp.output:
                    if item.type == "message":
                        for cc in item.message.content:
                            if cc.type == "text":
                                chunks.append(cc.text)
                return "\n".join(chunks).strip()
            except Exception:
                pass
        except Exception as e1:
            msg = str(e1)
            log.info(f"Responses API failed, fallback to Chat Completions: {msg}")

        # 2) Chat Completions API
        try:
            resp = await self._client.chat.completions.create(  # type: ignore[union-attr]
                model=self.model_mini,
                messages=[
                    {"role": "system", "content": system},
                    {"role": "user", "content": user},
                ],
                temperature=0.3,
                max_tokens=max_tokens,
            )
            return (resp.choices[0].message.content or "").strip()
        except Exception as e2:
            raise LLMError(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞—â–µ–Ω–∏—è –∫ LLM: {e2}")

    async def make_digest_ru(self, pairs: List[str]) -> Dict[str, str]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å {pair: '—Ç–µ–∫—Å—Ç –Ω–∞ —Ä—É—Å—Å–∫–æ–º'}.
        """
        sys = (
            "–¢—ã —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã–π —Ä–µ–¥–∞–∫—Ç–æ—Ä. –ü–∏—à–∏ –∫—Ä–∞—Ç–∫–æ –Ω–∞ —Ä—É—Å—Å–∫–æ–º, –±–µ–∑ –≤–æ–¥—ã, 2‚Äì4 –ø—É–Ω–∫—Ç–∞ –Ω–∞ –ø–∞—Ä—É. "
            "–¢–æ–Ω ‚Äî –¥–µ–ª–æ–≤–æ–π. –ò–∑–±–µ–≥–∞–π –∫–∞—Ç–µ–≥–æ—Ä–∏—á–Ω—ã—Ö –ø—Ä–æ–≥–Ω–æ–∑–æ–≤, –µ—Å–ª–∏ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏ –Ω–µ—Ç ‚Äî —É–∫–∞–∂–∏ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ."
        )
        user = (
            "–°–¥–µ–ª–∞–π –∫–æ—Ä–æ—Ç–∫–∏–π –¥–∞–π–¥–∂–µ—Å—Ç –ø–æ –≤–∞–ª—é—Ç–Ω—ã–º –ø–∞—Ä–∞–º: "
            f"{', '.join(pairs)}. –î–ª—è –∫–∞–∂–¥–æ–π –ø–∞—Ä—ã: –æ–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ —Å—Ç–∞—Ç—É—Å–∞-–∏–∫–æ–Ω–∫–∏ "
            "(–Ω–∞–ø—Ä–∏–º–µ—Ä ‚úÖ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ / ‚ö†Ô∏è –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ / üöß —Ä–∏—Å–∫), –∑–∞—Ç–µ–º 2‚Äì4 —Ç–µ–∑–∏—Å–∞: "
            "–∫–ª—é—á–µ–≤—ã–µ —Ä–∏—Å–∫–∏/—Å–æ–±—ã—Ç–∏—è —Å–µ–≥–æ–¥–Ω—è, –Ω–∞ —á—Ç–æ –æ–±—Ä–∞—Ç–∏—Ç—å –≤–Ω–∏–º–∞–Ω–∏–µ —Ç—Ä–µ–π–¥–µ—Ä—É –∏–Ω—Ç—Ä–∞–¥–µ–π. "
            "–ï—Å–ª–∏ –Ω–µ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –ø–æ–≤–æ–¥–æ–≤ ‚Äî –Ω–∞–ø–∏—à–∏ –∫–æ—Ä–æ—Ç–∫–æ ¬´–ù–µ–π—Ç—Ä–∞–ª—å–Ω–æ, —Ä–∞–±–æ—Ç–∞–µ–º –ø–æ –ø–ª–∞–Ω—É¬ª. "
            "–§–æ—Ä–º–∞—Ç: –¥–ª—è –ö–ê–ñ–î–û–ô –ø–∞—Ä—ã –æ—Ç–¥–µ–ª—å–Ω—ã–π –±–ª–æ–∫, —Å–Ω–∞—á–∞–ª–∞ —Ç–∏–∫–µ—Ä, –∑–∞—Ç–µ–º —Ç–µ–∫—Å—Ç. "
            "–ê–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä—ã: ISM, CPI, NFP, BoJ, RBA, ECB, BoE –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å, –Ω–æ –±–µ–∑ —Ñ–∞–Ω—Ç–∞–∑–∏–π."
        )

        try:
            content = await self._call_mini(sys, user, max_tokens=600)
        except LLMError:
            # –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π –¥–µ—Ñ–æ–ª—Ç
            return {p: "‚úÖ –ù–µ–π—Ç—Ä–∞–ª—å–Ω–æ. –°—É—â–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –ø–æ–≤–æ–¥–æ–≤ –Ω–µ –æ—Ç–º–µ—á–µ–Ω–æ; —Ä–∞–±–æ—Ç–∞–µ–º –ø–æ –±–∞–∑–æ–≤–æ–º—É –ø–ª–∞–Ω—É." for p in pairs}

        if not content:
            return {p: "‚úÖ –ù–µ–π—Ç—Ä–∞–ª—å–Ω–æ. –°—É—â–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –ø–æ–≤–æ–¥–æ–≤ –Ω–µ –æ—Ç–º–µ—á–µ–Ω–æ; —Ä–∞–±–æ—Ç–∞–µ–º –ø–æ –±–∞–∑–æ–≤–æ–º—É –ø–ª–∞–Ω—É." for p in pairs}

        # –ø—Ä–æ—Å—Ç–∞—è –Ω–∞—Ä–µ–∑–∫–∞ –ø–æ —Ç–∏–∫–µ—Ä–∞–º
        result: Dict[str, str] = {p: "" for p in pairs}
        lines = [ln.strip() for ln in content.splitlines() if ln.strip()]
        cur_key = None
        acc: Dict[str, List[str]] = {p: [] for p in pairs}
        for ln in lines:
            up = ln.upper()
            matched = None
            for p in pairs:
                if p in up:
                    matched = p
                    break
            if matched:
                cur_key = matched
                cleaned = ln.replace(matched, "").strip("-: \t")
                if cleaned:
                    acc[cur_key].append(cleaned)
                continue
            if cur_key:
                acc[cur_key].append(ln)

        for p in pairs:
            block = "\n".join(acc.get(p) or []).strip()
            if not block:
                block = "‚úÖ –ù–µ–π—Ç—Ä–∞–ª—å–Ω–æ. –°—É—â–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –ø–æ–≤–æ–¥–æ–≤ –Ω–µ –æ—Ç–º–µ—á–µ–Ω–æ; —Ä–∞–±–æ—Ç–∞–µ–º –ø–æ –±–∞–∑–æ–≤–æ–º—É –ø–ª–∞–Ω—É."
            result[p] = block
        return result
